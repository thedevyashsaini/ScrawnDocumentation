---
title: Advanced Usage
description: Advanced patterns, optimization techniques, and best practices
---

## Overview

This guide covers advanced usage patterns, optimization techniques, and best practices for production deployments with Scrawn.js.

## Batch Processing

When tracking multiple events, use `Promise.all` for better performance:

```typescript
import { Scrawn } from '@scrawn/core';

const scrawn = new Scrawn({
  apiKey: process.env.SCRAWN_KEY as `scrn_${string}`,
  baseURL: process.env.SCRAWN_BASE_URL || 'http://localhost:8069',
});

// Track multiple events in parallel
const events = [
  { userId: 'user-1', debitAmount: 100 },
  { userId: 'user-2', debitAmount: 200 },
  { userId: 'user-3', debitAmount: 150 },
];

await Promise.all(
  events.map(event => scrawn.sdkCallEventConsumer(event))
);
```

## Retry Logic

Implement robust retry logic with exponential backoff:

```typescript
async function trackWithRetry(
  userId: string,
  debitAmount: number,
  maxRetries = 3
) {
  let lastError: Error;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      await scrawn.sdkCallEventConsumer({ userId, debitAmount });
      return; // Success
    } catch (error) {
      lastError = error as Error;
      
      // Exponential backoff
      const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError;
}
```

## Async Event Tracking Pattern

In persistent servers, await after the response so that the response isn't dependent on the billing call.

```typescript title="app.ts"
app.post('/api/generate', async (req, res) => {
  await scrawn.sdkCallEventConsumer({ // [!code --]
    userId: req.user.id, // [!code --]
    debitAmount: 100, // [!code --]
  }); // [!code --]
  // Start tracking (don't await yet) // [!code ++]
  const trackingPromise = scrawn.sdkCallEventConsumer({ // [!code ++]
    userId: req.user.id, // [!code ++]
    debitAmount: 100, // [!code ++]
  }); // [!code ++]
  
  // Do your work
  const result = await generateContent(req.body.prompt);
  
  res.json({ result });
  
  // Wait for tracking to complete // [!code ++]
  await trackingPromise; // [!code ++]
});
```

## Queue-Based Processing

For high-throughput scenarios, use a queue to decouple tracking from request handling:

```typescript
import Queue from 'bull';

const usageQueue = new Queue('usage-tracking', {
  redis: process.env.REDIS_URL,
});

// Producer: Add to queue
app.post('/api/action', async (req, res) => {
  // Queue the event
  await usageQueue.add({
    userId: req.user.id,
    debitAmount: 10,
  });
  
  // Process request immediately
  const result = await doWork(req.body);
  res.json({ result, queued: true });
});

// Consumer: Process queue in background
usageQueue.process(async (job) => {
  const { userId, debitAmount } = job.data;
  await scrawn.sdkCallEventConsumer({ userId, debitAmount });
});
```

## Path Matching Utilities

The SDK exports a `matchPath` utility for custom path matching logic:

```typescript
import { matchPath } from '@scrawn/core';

// Use in your own middleware
const shouldTrack = (path: string): boolean => {
  // Exact match
  if (matchPath(path, '/api/generate')) return true;
  
  // Single segment wildcard
  if (matchPath(path, '/api/v1/*')) return true;
  
  // Multi-segment wildcard
  if (matchPath(path, '/api/**')) return true;
  
  return false;
};
```

## Monitoring and Analytics

Track usage patterns and errors for observability:

```typescript
async function trackUsageWithAnalytics(userId: string, debitAmount: number) {
  const startTime = Date.now();
  
  try {
    await scrawn.sdkCallEventConsumer({ userId, debitAmount });
    
    console.log('Usage tracked', {
      userId,
      amount: debitAmount,
      duration: Date.now() - startTime,
      status: 'success',
    });
  } catch (error) {
    console.error('Usage tracking failed', {
      userId,
      amount: debitAmount,
      duration: Date.now() - startTime,
      error: (error as Error).message,
    });
    
    throw error;
  }
}
```

## Error Handling

The SDK throws errors with detailed validation messages:

```typescript
try {
  await scrawn.sdkCallEventConsumer({
    userId: '',  // Invalid: empty string
    debitAmount: -5,  // Invalid: negative number
  });
} catch (error) {
  console.error(error.message);
  // "Payload validation failed: userId: must be a non-empty string, debitAmount: must be a positive number"
}
```

### Graceful Degradation

Allow your app to continue functioning even if tracking fails:

```typescript
async function trackUsageGracefully(userId: string, debitAmount: number) {
  try {
    await scrawn.sdkCallEventConsumer({ userId, debitAmount });
  } catch (error) {
    // Log error but don't block request
    console.error('Failed to track usage:', error);
    
    // Optional: Queue for later retry
    await queueForRetry({ userId, debitAmount, error });
  }
}
```

## Multi-Tenant Support

Create separate SDK instances for different tenants:

```typescript
interface TenantConfig {
  scrawnKey: string;
  scrawnBaseUrl: string;
}

const scrawnInstances = new Map<string, Scrawn>();

function getScrawnForTenant(tenantId: string, config: TenantConfig): Scrawn {
  if (!scrawnInstances.has(tenantId)) {
    scrawnInstances.set(tenantId, new Scrawn({
      apiKey: config.scrawnKey as `scrn_${string}`,
      baseURL: config.scrawnBaseUrl,
    }));
  }
  
  return scrawnInstances.get(tenantId)!;
}

// Usage
const scrawn = getScrawnForTenant('tenant-1', {
  scrawnKey: process.env.TENANT_1_KEY!,
  scrawnBaseUrl: process.env.SCRAWN_BASE_URL!,
});

await scrawn.sdkCallEventConsumer({ userId: 'user-123', debitAmount: 10 });
```

## Performance Optimization

### Reuse SDK Instance

```typescript title="scrawn.ts"
// Create once, reuse everywhere
const scrawn = new Scrawn({
  apiKey: process.env.SCRAWN_KEY as `scrn_${string}`,
  baseURL: process.env.SCRAWN_BASE_URL || 'http://localhost:8069',
});

export default scrawn;
```

```typescript title="bad-example.ts"
// Don't create new instances repeatedly // [!code --]
function trackEvent() { // [!code --]
  const scrawn = new Scrawn({ /* ... */ }); // [!code --]
  await scrawn.sdkCallEventConsumer({ /* ... */ }); // [!code --]
} // [!code --]
```
